---
title: "RmarkdownProjekt"
author: "Clement"
date: "2025-08-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#  benötigte Pakete importieren und installieren 

```{r}
# Liste der benötigten Pakete


# In diesem Vektor werden alle Paketnamen als Strings gespeichert. Jedes Paket bringt eigene Funktionen mit, die im Projekt genutzt werden.

pakete <- c(
  "tidyverse",    # Sammlung von Paketen für Datenbearbeitung, -bereinigung und Visualisierung
  "readxl",       # Zum Einlesen von Excel-Dateien (.xls, .xlsx)
  "plotly",       # Erstellung interaktiver Diagramme
  "skimr",        # Übersichtliche Zusammenfassung von Datensätzen
  "car",          # Werkzeuge für Regressionsanalyse und Hypothesentests
  "corrplot",     # Grafische Darstellung von Korrelationsmatrizen
  "vcd",          # Visualisierung kategorialer Daten
  "dplyr",        # Datenmanipulation (Teil von tidyverse, hier separat geladen)
  "broom",        # Statistische Modellergebnisse in tabellarischer Form aufbereiten
  "stringr",      # Arbeiten mit Zeichenketten (Strings)
  "purrr",        # Funktionale Programmierung und Iterationen
  "caret",        # Machine-Learning-Framework für Klassifikation und Regression
  "VIM",           # Visualisierung und Imputation fehlender Werte
  "patchwork",
  "MASS",
  "leaps"
)

# Funktion zum Installieren und Laden fehlender Pakete
# Diese Funktion prüft, ob das Paket bereits installiert ist.
# Falls nicht, wird es installiert.

installiere_und_lade_wenn_nicht_vorhanden <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {  # Prüfen, ob Paket vorhanden ist
    install.packages(pkg)                       # Falls nicht: installieren
  }
  library(pkg, character.only = TRUE)           # Laden (Name als Zeichenkette übergeben)
}

# Alle Pakete installieren und laden

lapply(pakete, installiere_und_lade_wenn_nicht_vorhanden)

```

# A.Datenimportation und  Exploration 

```{r}
# Daten importieren
cars_df <- read_csv("C:\\Users\\cleme\\Desktop\\Multivariate_Datenanalyse\\Daten\\cars.csv")
# Datenexploration
  ## Daten ansehen
# View(cars_df)
cars_df$...1  <- NULL
 
```

# B. Datenbereinigung

##B.1 Duplikate ?

```{r}
cars_df[duplicated(cars_df),]
```


## B.2 unlogische Werte
### B.2.1 unlogische Werte?
```{r}
# Übersicht aller Spalten (numerisch: Kennzahlen, nicht-numerisch: Datentyp)
summary(cars_df)

# Kategoriale Spalten identifizieren (alles außer numerisch)
kategorielle_spalten <- !sapply(cars_df, is.numeric)

# Häufigkeitstabellen für kategoriale Spalten erstellen
sapply(cars_df[kategorielle_spalten], table)

```

###  B.2.2 unlogische Werte ersetzen 
```{r}
cars_df[cars_df=="?"]<-"NA"
cars_df[cars_df=="std"]<-"standard"
```

## B.3 Nicht geeignete Datentypen
### B.3.1 Nicht geeignete Datentypen ? 
ja: Es gibt Spalten, die den Datentyp character haben statt numerisch:tueren,anzahl_zylinder,kolben_durchmesser,stroke,PS,drehzahl_max und preis  

```{r}

    ## Datenstruktur anschauen
str(cars_df)
                                    
```

### B.3.2 nicht geeignete Datentypen behandeln
```{r}

cars_df <- cars_df %>%                                                 # Startet eine Daten-Transformation mit dem Pipe-Operator (%>%)
  mutate(                                                              # Öffnet mutate(), um neue Werte zu berechnen bzw. Spalten zu ändern
    anzahl_zylinder    = dplyr::recode(anzahl_zylinder,                # Ersetzt Textwerte in 'anzahl_zylinder' durch Ziffern als Strings
                                "four" = "4",                          # "four" → "4"
                                "six" = "6",                           # "six"  → "6"
                                "five" = "5",                          # "five" → "5"
                                "three" = "3",                         # "three" → "3"
                                "twelve" = "12",                       # "twelve" → "12"
                                "two" = "2",                           # "two" → "2"
                                "eight" = "8"),                        # "eight" → "8"
    anzahl_zylinder    = as.integer(anzahl_zylinder),                  # Wandelt die recodierten Strings in Ganzzahlen (Integer) um

    tueren             = dplyr::recode(tueren,                         # Ersetzt Textwerte in 'tueren' durch Ziffern als Strings
                                "two" = "2",                           # "two" → "2"
                                "four" ="4",                           # "four" → "4"
                                "NA" = "NA"),                            # Lässt unbekannte Werte ("?") unverändert
    tueren             = as.integer(tueren),                           # Wandelt 'tueren' in Ganzzahlen um (NA für nicht konvertierbare Werte)

    kolben_durchmesser = as.double(kolben_durchmesser),                # Wandelt 'kolben_durchmesser' in numerischen Typ double um
    stroke             = as.double(stroke),                            # Wandelt 'stroke' in double um
    PS                 = as.double(PS),                                # Wandelt 'PS' in double um
    drehzahl_max       = as.double(drehzahl_max),                       # Wandelt 'drehzahl_max' in double um
    preis              = as.double(preis)                              # Wandelt 'preis' in double um
  )

str(cars_df)                                                           # Zeigt die Struktur des Dataframes inkl. neuer Spaltentypen

```

## B.4 Fehlende Werte 
### B.4.1 Fehlende Werte?
```{r}



# Eine Tabelle der fehlenden Werte erstellen
fehlende_Werte <- as.data.frame(colSums(is.na(cars_df)))
colnames(fehlende_Werte) <- "Anzahl_Fehlende_Werte"

# Relative Häufigkeit berechnen
fehlende_Werte$Haeufigkeit_Prozent <- round((fehlende_Werte$Anzahl_Fehlende_Werte / nrow(cars_df)) * 100, 2)

# Sortieren der Tabelle nach Anzahl der fehlenden Werte (absteigend)
fehlende_Werte <- fehlende_Werte %>% arrange(desc(Anzahl_Fehlende_Werte))

# Die sortierte Tabelle anzeigen
head(fehlende_Werte, n = 8)

```


### B.4.2 Fehlende Werte entfernen
```{r}
colSums(is.na(cars_df))                            # Zählt, wie viele NA-Werte es in jeder Spalte von 'cars_df' gibt
cars_df <- cars_df[rowSums(is.na(cars_df)) == 0, ] # Entfernt alle Zeilen, die mindestens einen NA-Wert enthalten
cat("\n\n")                                        # zwei Leerzeilen einfügen, um die Ausgaben zu trennen
colSums(is.na(cars_df))                            # Prüft erneut die Anzahl der NA-Werte pro Spalte nach dem Entfernen
```


## B.5   Außreiser ?
### B.5.1   Außreiser ?

```{r}
# ---- Funktion zur Ermittlung der Ausreißer-Indizes nach der IQR-Methode ----
find_outliers_iqr <- function(x) {
  x_clean <- x[!is.na(x)]                      # fehlende Werte (NA) entfernen, damit Quantile korrekt berechnet werden
  Q1 <- quantile(x_clean, 0.25, na.rm = TRUE)  # 1. Quartil (25%-Perzentil) berechnen
  Q3 <- quantile(x_clean, 0.75, na.rm = TRUE)  # 3. Quartil (75%-Perzentil) berechnen
  IQR <- Q3 - Q1                               # Interquartilsabstand (Q3 minus Q1)
  lower <- Q1 - 1.5 * IQR                      # untere Grenze für Ausreißer bestimmen
  upper <- Q3 + 1.5 * IQR                      # obere Grenze für Ausreißer bestimmen
  which(x < lower | x > upper)                 # Indizes der Werte zurückgeben, die außerhalb der Grenzen liegen
}

# ---- Hilfsfunktion: numerische Spalten extrahieren und Ausreißer pro Spalte zählen ----
get_outlier_counts <- function(df) {
  numeric_cols <- sapply(df, is.numeric)               # logischer Vektor: welche Spalten sind numerisch?
  numeric_df <- df[, numeric_cols]                     # nur die numerischen Spalten auswählen
  outlier_indices <- lapply(numeric_df, find_outliers_iqr)  # für jede Spalte Ausreißer-Indizes ermitteln
  sapply(outlier_indices, length)                      # Anzahl der Ausreißer pro Spalte zurückgeben
}

# ---- Ausreißer  zählen ----
outlier_counts_before <- get_outlier_counts(cars_df)  # Hilfsfunktion auf den ursprünglichen Dataframe anwenden
print(outlier_counts_before)                          # Anzahl der Ausreißer pro Spalte vor der Ersetzung ausgeben
cat("\n\n")                                           # zwei Leerzeilen einfügen, um die Ausgaben zu trennen


```
### B.5.2 Außreiser entfernen


```{r}
# ---- Ausreißer durch untere/obere Grenze ersetzen ----
numeric_cols <- sapply(cars_df, is.numeric)           # prüfen, welche Spalten numerisch sind

for (colname in names(cars_df)[numeric_cols]) {       # jede numerische Spalte durchgehen
  vec <- cars_df[[colname]]                           # Spaltenvektor extrahieren
  x_clean <- vec[!is.na(vec)]                         # NAs für die Berechnung entfernen
  
  if (colname == "anzahl_zylinder") {
    # Für anzahl_zylinder: unteres 10%-Perzentil, oberes 90%-Perzentil
    lower <- quantile(x_clean, 0.10, na.rm = TRUE)
    upper <- quantile(x_clean, 0.90, na.rm = TRUE)
  } else {
    # Für alle anderen numerischen Spalten: klassische IQR-Methode
    Q1 <- quantile(x_clean, 0.25, na.rm = TRUE)
    Q3 <- quantile(x_clean, 0.75, na.rm = TRUE)
    IQR <- Q3 - Q1
    lower <- Q1 - 1.5 * IQR
    upper <- Q3 + 1.5 * IQR
  }

  # Werte außerhalb der Grenzen ersetzen
  vec[vec < lower] <- lower
  vec[vec > upper] <- upper
  cars_df[[colname]] <- vec                              # bereinigten Vektor zurückschreiben
}

# ---- Ausreißer zur Prüfung nach dem Ersetzen zählen ----
outlier_counts_after <- get_outlier_counts(cars_df)     # erneut zählen
print(outlier_counts_after)                              # Anzahl der Ausreißer pro Spalte ausgeben
cat("\n\n")                                              # zwei Leerzeilen


```






# C. Analyse der Daten und Ableitung von Aussagen
## C.1 Univariate Analyse
### C.1.1 Quantitative Merkmale
```{r}
# Numerische Spalten extrahieren
num_cols <- sapply(cars_df, is.numeric)           # Prüft für jede Spalte, ob sie numerisch ist, Ergebnis: logischer Vektor
numeric_df <- cars_df[, num_cols]                 # Wählt nur die numerischen Spalten aus dem Dataframe aus
# Für jede numerische Spalte: Summary, Boxplot, Histogramm, Density Plot
for (col_name in names(numeric_df)) {             # Schleife über alle Spaltennamen der numerischen Spalten
  data_vector <- numeric_df[[col_name]]           # Extrahiert die Spalte als Vektor
  
  # Nur mit vollständigen Werten arbeiten (für density)
  data_vector <- data_vector[!is.na(data_vector)] # Entfernt fehlende Werte (NAs) aus dem Vektor
  
  # Layout: 1 Zeile, 4 Spalten
  par(mfrow = c(1, 4))                            # Setzt das Plot-Layout auf 1 Zeile, 4 Spalten
  
  
  # 1. Summary-Statistik + Standardabweichung
  plot.new()                                      # Öffnet einen neuen, leeren Plot (für Textausgabe)
  summary_stats <- summary(data_vector)           # Berechnet Min, 1.Quartil, Median, Mittelwert, 3.Quartil, Max
  std_dev <- sd(data_vector)                      # Berechnet die Standardabweichung (NAs sind schon entfernt)
  IQR<- quantile(data_vector,0.75)-quantile(data_vector,0.25) # Berechnet den Interquartilsabstand 
  
  # Titel
  title_text <- paste("Summary")    
  text(x = 0, y = 1, labels = title_text, adj = 0, font = 2, cex = 1.6)   # Zeichnet den Titel im Plot (links oben, fett, größere Schrift)
  
  # Zeilenweise Ausgabe
  y_pos <- 0.9                                    # Startposition für den Text (etwas unter dem Titel)
  line_spacing <- 0.1                             # Abstand zwischen den Textzeilen
  for (i in seq_along(summary_stats)) {           # Schleife über alle Summary-Werte
    label <- names(summary_stats)[i]              # Label (z.B. "Min.", "Median")
    value <- round(summary_stats[i], 2)           # Wert auf 2 Dezimalstellen runden
    text_line <- paste0(label, ": ", value)       # Textzeile zusammenbauen
    text(x = 0, y = y_pos, labels = text_line, adj = 0, cex = 1.3)  # Text in Plot schreiben (linksbündig, größere Schrift)
    y_pos <- y_pos - line_spacing                 # Y-Position für nächste Zeile nach unten verschieben
  }
  
  # Standardabweichung anzeigen
  text(x = 0, y = y_pos, labels = paste0("SD: ", round(std_dev, 2)), adj = 0, cex = 1.3)  # SD unten anhängen (größere Schrift)
  
  y_pos <- y_pos - line_spacing                            # Abstand zwischen den Textzeilen 
  
  # Interquartilsabstände anzeigen
  text(x = 0, y = y_pos, labels = paste0("IQR: ", round(IQR, 2)), adj = 0, cex = 1.3)  # IQR unten anhängen (größere Schrift)
  
  # 2. Boxplot
  boxplot(data_vector,
          main = paste("Boxplot:", col_name),     # Titel mit Spaltenname
          ylab = col_name)                        # Y-Achsen-Beschriftung
  
  # 3. Histogramm
  hist(data_vector,
       main = paste("Histogramm:", col_name),     # Titel
       xlab = col_name,                           # X-Achsen-Beschriftung
       col = "lightblue",                         # Balkenfarbe
       border = "black")                          # Rahmenfarbe der Balken
  
  # 4. Density Plot
  dens <- density(data_vector)                    # Dichtefunktion schätzen
  plot(dens,
       main = paste("Density Plot:", col_name),   # Titel
       xlab = col_name,                           # X-Achsen-Beschriftung
       col = "darkgreen",                         # Linienfarbe
       lwd = 2)                                   # Linienbreite
  polygon(dens, col = rgb(0, 1, 0, 0.3), border = "darkgreen")  # Fläche unter der Dichte halbtransparent ausfüllen
}


```







### C.1.2 qualitative Merkmale
```{r}
# Nicht-numerische Spalten extrahieren
num_cols <- sapply(cars_df, is.numeric)               # Logischer Vektor: TRUE für numerische Spalten
char_df <- cars_df[, !num_cols]                       # Wählt nur die nicht-numerischen Spalten aus

# Für jede nicht-numerische Spalte: Summary, Barplot, Häufigkeitstabelle
for (col_name in names(char_df)) {                    # Schleife über alle nicht-numerischen Spaltennamen
  data_vector <- as.factor(char_df[[col_name]])       # Spalte als Faktor behandeln (Kategorien)
  
  # Layout: 1 Zeile, 3 Spalten
  par(mfrow = c(1, 3))                                # Plot-Layout auf 1 Zeile, 3 Spalten setzen
  
  # 1. Summary-Statistik (Textfeld)
  plot.new()                                          # Neuer leerer Plot für Textausgabe
  title_text <- paste("Summary")                      # Titeltext mit Spaltennamen erzeugen
  text(x = 0, y = 1, labels = title_text, adj = 0, font = 2,cex = 1.3)  # Titel links oben, fett
  y_pos <- 0.9                                        # Start-Y-Position für Text unter Titel
  line_spacing <- 0.1                                 # Abstand zwischen Textzeilen
  
  # Anzahl Kategorien
  n_levels <- length(levels(data_vector))             # Anzahl eindeutiger Kategorien bestimmen
  text(x = 0, y = y_pos, labels = paste0("Anzahl Kategorien: ", n_levels), adj = 0,cex = 1.3) # Ausgabe Anzahl Kategorien
  y_pos <- y_pos - line_spacing                       # Y-Position nach unten verschieben
  
  # Häufigste Kategorie
  freq_table <- table(data_vector)                     # Häufigkeitstabelle der Kategorien erstellen
  sorted_freq <- sort(freq_table, decreasing = TRUE)   # Tabelle absteigend nach Häufigkeit sortieren
  top_level <- names(sorted_freq)[1]                   # Name der häufigsten Kategorie
  top_freq <- sorted_freq[1]                           # Häufigkeit der häufigsten Kategorie
  text(x = 0, y = y_pos, labels = paste0("Häufigste Kategorie: ", top_level, " (", top_freq, ")"), adj = 0,cex = 1.3) # Ausgabe
  
  # 2. Barplot (auch sortiert)
  barplot(sorted_freq,                                 # Barplot der Häufigkeiten zeichnen
          main = paste("Barplot:", col_name),          # Titel mit Spaltennamen
          las = 2,                                     # Drehung der Achsenbeschriftung (senkrecht)
          col = "lightblue",                           # Balkenfarbe
          border = "black",                            # Balkenumrandung
          cex.names = 1)                             # Schriftgröße der Balkennamen
  
  # 3. Häufigkeitstabelle als Text (sortiert, relativ + absolut)
  plot.new()                                          # Neuer leerer Plot für Textausgabe
  total <- sum(freq_table)                            # Gesamtanzahl Beobachtungen (ohne NA)
  rel_freq <- round(100 * sorted_freq / total, 1)     # Relative Häufigkeit in Prozent, gerundet
  text(x = 0, y = 1, labels = "Häufigkeiten", adj = 0, font = 2,cex = 1.3)  # Überschrift
  y_pos <- 0.9                                        # Startposition für die Häufigkeiten
  max_display <- min(length(sorted_freq), 8)          # Maximal 8 Kategorien anzeigen
  
  for (i in 1:max_display) {                          # Schleife für die Top-Kategorien
    label <- names(sorted_freq)[i]                    # Kategorie-Name
    abs_val <- sorted_freq[i]                         # Absolute Häufigkeit
    rel_val <- rel_freq[i]                            # Relative Häufigkeit
    text_line <- paste0(label, ": ", abs_val, " (", rel_val, "%)")  # Text zusammensetzen
    text(x = 0, y = y_pos, labels = text_line, adj = 0, cex = 1.3) # Text ausgeben
    y_pos <- y_pos - line_spacing                      # Y-Position weiter nach unten verschieben
  }
  
  if (length(sorted_freq) > max_display) {            # Wenn mehr Kategorien vorhanden sind als angezeigt
    text(x = 0, y = y_pos, labels = "... (weitere Kategorien)", adj = 0,cex = 1.3)  # Hinweis ausgeben
  }
  
  # Layout zurücksetzen
  par(mfrow = c(1, 1))                                # Plot-Layout auf Standard zurücksetzen
}

```




## C.2 Multivariate Analysis
### C.2.1 Scatterplots

```{r}
numeric_df <- cars_df[, sapply(cars_df, is.numeric)]          # Nur numerische Spalten aus cars_df auswählen
target <- "preis"                                             # Zielvariable definieren
predictors <- numeric_df[, names(numeric_df) != target]       # Alle numerischen Spalten außer "preis" als Prädiktoren

long_df <- cbind(preis = numeric_df[[target]], predictors) %>% # preis-Spalte mit Prädiktoren zusammenfügen
  as.data.frame() %>%                                          # sicherstellen, dass es ein Dataframe ist
  pivot_longer(cols = -preis, names_to = "Predictor",          # alle Spalten außer preis stapeln
               values_to = "Value")                           # neue Spalten: "Predictor" = Name, "Value" = Wert

ggplot(long_df, aes(x = Value, y = preis)) +                   # Datenquelle: long_df, Achsen: Value (x), preis (y)
  geom_point() +                                               # Punkte zeichnen
  facet_wrap(~ Predictor, scales = "free_x") +                 # für jeden Predictor eigenes Panel mit eigener x-Achse
  labs(x = NULL, y = "preis",                                  # Achsenbeschriftung und Titel
       title = "Scatterplots: Preis vs Prädiktoren") +
  theme_minimal()                                              # minimalistisches Layout
```





### C.2.2 Korelationsmatrix
Merkmale, die gut mit der Zielvariable Preis korreliert sind, sind:  Radstand, Laenge, Breite, Gewicht, Anzahl_zylender,motor_groesse,kolben_durchmesser,
PS,verbrauch_stadt_mpg und verbrauch_autobahn_mpg.

```{r}
# 1. Nur numerische Spalten extrahieren
num_cols <- sapply(cars_df, is.numeric)
numeric_df <- cars_df[, num_cols]

# 2. Korrelationsmatrix berechnen
cor_matrix <- cor(numeric_df)

# 3. Mixed Corrplot erzeugen
corrplot.mixed(cor_matrix)


```


### C.2.3 preis vs qualitativen Variablen
#### C.2.3.1 preis vs qualitativen Variablen vor Binning
```{r}
# 1. Nicht-numerische Spalten extrahieren (ohne Preis)
non_numeric_cols <- !sapply(cars_df, is.numeric)
cat_df <- cars_df[, non_numeric_cols]

# 2. Preis-Spalte
preis_vector <- cars_df$preis

# Anzahl der kategorialen Variablen
n_cols <- ncol(cat_df)

# Layout vorbereiten (z. B. 2 Zeilen, 3 Spalten)
par(mfrow = c(ceiling(n_cols/3), 3), mar=c(5,4,4,2))  # 3 pro Reihe

# 3. Schleife für jede kategoriale Variable
for (col_name in names(cat_df)) {
  kategorie <- as.factor(cat_df[[col_name]])
  
  if (length(unique(na.omit(kategorie))) > 1) {
    # Median pro Kategorie berechnen
    median_preis <- tapply(preis_vector, kategorie, median, na.rm = TRUE)
    
    # Kategorien nach Median sortieren
    sorted_levels <- names(sort(median_preis, decreasing = TRUE))
    kategorie <- factor(kategorie, levels = sorted_levels)
    median_preis <- median_preis[sorted_levels]
    
    # Boxplot erstellen
    boxplot(preis_vector ~ kategorie,
            main = paste("Preis vs", col_name),
            xlab = "",
            ylab = "Preis",
            col = "lightblue",
            las = 2,
            cex.axis = 0.7)
    
    # Medianpunkte hinzufügen
    points(1:length(median_preis), median_preis, col = "red", pch = 19)
    
    # Linie durch Medianpunkte
    lines(1:length(median_preis), median_preis, col = "red", lwd = 2)
  }
}



```



#### C.2.3.2 Binning 

```{r}
cars_df <- cars_df %>%
  dplyr::mutate(
    hersteller = case_when(
      hersteller %in% c("jaguar", "mercedes-benz", "porsche", "bmw") ~ "LS",
      hersteller %in% c("volvo", "audi", "peugot", "mercury", "alfa-romero", "saab", "volkswagen") ~ "MS",
      hersteller %in% c("toyota", "isuzu", "mazda", "mitsubishi", "nissan", "subaru", 
                        "plymouth", "honda", "dodge", "chevrolet") ~ "NS",
      TRUE ~ NA_character_
    ),
    kraftstoff_system = case_when(
      kraftstoff_system %in% c("mpfi", "idi") ~ "mpfi_idi",
      kraftstoff_system %in% c("mfi", "spfi", "spdi") ~ "mfi_spfi_spdi",
      kraftstoff_system %in% c("2bbl", "1bbl") ~ "2bbl_1bbl",
      TRUE ~ NA_character_
    ),
    karosserie_form = case_when(
      karosserie_form %in% c("hardtop","convertible") ~ "hardtop_convertible",
      karosserie_form %in% c("wagon","sedan") ~ "wagon_sedan",
      karosserie_form %in% c("hatchback") ~ "hatchback",
      TRUE ~ NA_character_
    ),
    motorsteuerung = case_when(
      motorsteuerung %in% c("ohcv") ~ "ohcv",
      motorsteuerung %in% c("dohc","l") ~ "dohc_l",
      motorsteuerung %in% c("ohcf","ohc") ~ "ohcf_ohc",
      TRUE ~ NA_character_
    ),
    # NEU: Antrieb separat behandeln
    antrieb_typ = case_when(
      antrieb_typ %in% c("rwd") ~ "nwd",
      antrieb_typ %in% c("fwd", "4wd") ~ "4wd_fwd",
      TRUE ~ NA_character_
    )
  )

```



#### C.2.3.3  Preis vs Qualitative Merkmale nach Binning

```{r}
# 1. Nicht-numerische Spalten extrahieren (ohne Preis)
non_numeric_cols <- !sapply(cars_df, is.numeric)
cat_df <- cars_df[, non_numeric_cols]

# 2. Preis-Spalte
preis_vector <- cars_df$preis

# 3. Anzahl Plots und Layout berechnen
num_plots <- ncol(cat_df)
rows <- ceiling(sqrt(num_plots))
cols <- ceiling(num_plots / rows)
par(mfrow = c(rows, cols), mar = c(5,5,4,2))

# 4. Schleife für jede kategoriale Variable
for (col_name in names(cat_df)) {
  kategorie <- as.factor(cat_df[[col_name]])
  
  if (length(unique(na.omit(kategorie))) > 1) {
    # Median pro Kategorie berechnen
    median_preis <- tapply(preis_vector, kategorie, median, na.rm = TRUE)
    
    # Kategorien nach Median sortieren
    sorted_levels <- names(sort(median_preis, decreasing = TRUE))
    kategorie <- factor(kategorie, levels = sorted_levels)
    median_preis <- median_preis[sorted_levels]
    
    # Boxplot erstellen
    boxplot(preis_vector ~ kategorie,
            main = paste("Boxplot von Preis vs", col_name),
            xlab = col_name,
            ylab = "Preis",
            col = "lightblue",
            las = 2)
    
    # Medianpunkte hinzufügen
    points(1:length(median_preis), median_preis, col = "red", pch = 19)
    
    # Linie durch Medianpunkte
    lines(1:length(median_preis), median_preis, col = "red", lwd = 2)
  }
}

# Layout zurücksetzen
par(mfrow = c(1,1))

```




## C.3 Multiple lineare Regression
### C.3.1 Merkmalsauswahl + Datenaufteilung in Traindaten und Testdaten
```{r}
set.seed(120)                                                 # Setze Zufallssamen für Reproduzierbarkeit


# ---- Numerische Spalten auswählen ----


numeric_vars <- c(  "breite", "anzahl_zylinder",
                  "motor_groesse", "kolben_durchmesser",
               "verbrauch_autobahn_mpg","preis")

#numeric_vars <- c("radstand", "laenge","verbrauch_autobahn_mpg",
#                  "motor_groesse", "kolben_durchmesser","preis"
#                ),"verbrauch_stadt_mpg","gewicht","radstand","PS","laenge"

# ---- Kategorische Spalten auswählen (Beispiel) ----
categorical_vars <- names(cars_df)[!sapply(cars_df, is.numeric)]  # alle nicht-numerischen Spalten
# Schritt 2: Definieren Sie die Variablen, die Sie ausschließen möchten


# ---- Dataframe mit ausgewählten Spalten erstellen ----
cars_df_select <- cars_df[, c(categorical_vars, numeric_vars)]


# 3. Train/Test-Split
train_ratio <- 0.8                                            # Anteil Trainingsdaten (80%)
n <- nrow(cars_df_select)                                        # Gesamtanzahl der Zeilen
train_indices <- sample(1:n, size = floor(train_ratio * n))   # Zufällige Auswahl der Trainingsindizes
train_df <- cars_df_select[train_indices, ]                      # Trainingsdaten
test_df  <- cars_df_select[-train_indices, ]                     # Testdaten
                   # Testdaten
```




### C.3.2 Forward- und Backward-Selection + modelbildung

```{r}


# 1. Start-Modell (Start mit allen Variablen)
# Verwenden Sie das vollständige Modell aus Ihrem Backward-Code als Startpunkt
full_model <- lm(preis ~ ., data = train_df)

# 2. Leeres Modell (Start ohne Variablen)
# Dies ist der Startpunkt für die Forward-Selection, um alle verfügbaren Variablen zu berücksichtigen
empty_model <- lm(preis ~ 1, data = train_df)

# 3. Führen Sie die Stepwise-Regression durch (kombinierte Auswahl)
# direction = "both" kombiniert Forward- und Backward-Selection
# scope definiert den kleinsten und größten möglichen Modellumfang
model <- stepAIC(full_model,
                                    scope = list(lower = empty_model, upper = full_model),
                                    direction = "both",
                                    trace = 1) # trace = 1 zeigt die einzelnen Schritte
summary(model)

```



### C.3.3 Modelprämise Prüfen
 Homoskedastizität: Die Störgrößen haben eine konstante Varianz
 Die Störgrößen sind normalverteilt .

```{r}
# Alle Diagnoseplots auf einmal anzeigen
par(mfrow = c(2, 2))  # 2x2 Layout für die Plots
plot(model)

```



```{r}
boxCox(model)
```




### C.3.4 Model verbessern
```{r}
# Ursprüngliche Modellformel aus dem bestehenden Modell extrahieren
final_formula <- formula(model)

# Transformation: Zielvariable (linke Seite der Formel) mit sqrt() transformieren
# z.B. aus (preis ~ x1 + x2 + ...) wird (sqrt(preis) ~ x1 + x2 + ...)
transformed_formula <- update(final_formula, sqrt(.) ~ .)

# Neues lineares Modell mit der transformierten Formel und train_df schätzen
Tmodel <- lm(formula = transformed_formula, data = train_df)

# Zusammenfassung des transformierten Modells ausgeben
summary(Tmodel)


```




### C.3.5 prämise der verbesserte Models Prüfen


```{r}
# Alle Diagnoseplots auf einmal anzeigen
par(mfrow = c(2, 2))  # 2x2 Layout für die Plots
plot(Tmodel)

```





### C.3.6 Modellleistung

```{r}


# 1. Datensätze in einer Liste speichern
data_list <- list(
  Training_Set = train_df,
  Test_Set     = test_df
)

# 2. Funktion, die alle Schritte für einen Datensatz ausführt
# (Anpassung der Faktorstufen, Vorhersage, Performance-Bewertung)
evaluate_and_plot <- function(df, model, name) {
  # Faktorstufen anpassen
  model_levels <- model$xlevels
  for (factor_name in names(model_levels)) {
    if (factor_name %in% names(df)) {
      df[[factor_name]] <- factor(df[[factor_name]], levels = model_levels[[factor_name]])
    }
  }
  
  # Vorhersagen und Performance berechnen
  df$predicted <- predict(model, newdata = df)
  performance <- postResample(pred = df$predicted, obs = df$preis)
  
  # Plot erstellen
  p <- ggplot(df, aes(x = preis, y = predicted)) +
    geom_point(color = "darkblue", alpha = 0.6, size = 2) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_abline(intercept = 0, slope = 1, color = "darkgreen", linetype = "solid", linewidth = 1) +
    labs(
      x = "Tatsächlicher Preis",
      y = "Vorhergesagter Preis",
      title = paste0("Vorhergesagter vs. tatsächlicher Preis\n(", name, " Datensatz)")
    ) +
    theme_minimal()
  
  return(list(performance = performance, plot = p))
}

# 3. Den Prozess über die Liste der Datensätze mappen (iterieren)
results <- map(names(data_list), ~evaluate_and_plot(data_list[[.x]], Tmodel, .x))
names(results) <- names(data_list)

# 4. Ergebnisse ausgeben
performance_list <- map(results, "performance")
performance_df <- as.data.frame(performance_list)
colnames(performance_df) <- names(data_list)
print(performance_df)

# 5. Plots ausgeben
plots <- map(results, "plot")
wrap_plots(plots)
```








